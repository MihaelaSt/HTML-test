<p>HTML Test</p>
<h1>On Abstractions and For-Each Performance in C#</h1>
<p>Donald Knuth famously said:</p>
<p><q>We should forget about small efficiencies, say about 97% of the time.</q></p>
<p>But when faced with the other 3%, it is good to know what's going on behind the scenes. So in this article we'll be taking a dive into the foreach loop.</p>
<p>A common misconception is the foreach loop in C# operates on <a href="https://msdn.microsoft.com/en-us/library/system.collections.ienumerable.aspx">IEnumerable</a>. That is almost correct, but it actually operates on anything that looks like an IEnumerable. That means it must have a GetEnumerator method and that method must return an object (or struct) with Current and MoveNext methods, the latter of which returns a Boolean.</p>
<h2>Disassembling the code:</h2>
<p>We now turn our attention to the disassembled IL code for the three tests.</p>
<h3>For loops</h3>
<p>So we know why using a foreach over a List is faster than the same list wrapped in an IList or IEnumerable. But what if we were to use a for loop instead of a foreach?</p>
<p><code> private static void Test4(IList list) { var sw = Stopwatch.StartNew(); var count = 0; for (int i = 0; i &lt; list.Count; i++) count += list[i]; sw.Stop(); Console.WriteLine("List for: " + sw.Elapsed.TotalMilliseconds.ToString("N2")); } </code></p>
<p>This time we&rsquo;re seeing an average runtime of 698.9598 ms (24.5606 ms StdDev). Slower than our foreach+List case, but still 20% faster than when we started.</p>
<p><code>private static void Test5(List list)</code></p>
<p>Testing it again with a for loop over a List, we see the numbers drop by an order of magnitude. With an average runtime of 105.6321 ms (1.1690 ms StdDev), we're 63% faster than our next best case and 88% faster than our worst case.</p>
<h4>What about LINQ?</h4>
<p>For our next set of tests, we'll only be counting the even numbered rows. <em>Common knowledge </em>is LINQ is slower than normal loops because it uses delegates, but is that true?</p>
<p>We ran theses four tests with an 1000 item list:</p>
<ul>
<li>IList with LINQ Where clause: list.Where(x =&gt; x % 2 == 0)</li>
<li>IList with an if-statement: if (item % 2 == 0)</li>
<li>List with LINQ Where clause</li>
<li>List with an if-statement</li>
</ul>
<p><em>Common wisdom </em>is that LINQ is slower than if statements, but that's not always the case.</p>
<table width="598">
<tbody>
<tr>
<td width="149">
<p><strong>Variable</strong></p>
</td>
<td width="149">
<p><strong>Conditional</strong></p>
</td>
<td width="149">
<p><strong>Mean ms</strong></p>
</td>
<td width="149">
<p><strong>StdDev ms</strong></p>
</td>
</tr>
<tr>
<td width="149">
<p>IList</p>
</td>
<td width="149">
<p>LINQ</p>
</td>
<td width="149">
<p>868.1882</p>
</td>
<td width="149">
<p>9.2918</p>
</td>
</tr>
<tr>
<td width="149">
<p>IList</p>
</td>
<td width="149">
<p>if-statement</p>
</td>
<td width="149">
<p>911.8603</p>
</td>
<td width="149">
<p>7.4000</p>
</td>
</tr>
<tr>
<td width="149">
<p>List</p>
</td>
<td width="149">
<p>LINQ</p>
</td>
<td width="149">
<p>871.5804</p>
</td>
<td width="149">
<p>12.1582</p>
</td>
</tr>
<tr>
<td width="149">
<p>List</p>
</td>
<td width="149">
<p>if-statement</p>
</td>
<td width="149">
<p>319.2920</p>
</td>
<td width="149">
<p>12.7303</p>
</td>
</tr>
</tbody>
</table>
<p>The slowest turned out to be IList with an if-statement . When using LINQ, performance actually improved by 4 to 5%. But if we use a List with an if-statement , then we see a 65% improvement of the worst case.</p>
<h5><strong>Environmental Flaws</strong></h5>
<p>An environmental flaw comes from the fact the world isn't perfect. This includes scenarios such as when the database is down, a web server is unresponsive, a file is missing, etc. When environmental flaws appear in bug reports two things need to be considered:</p>
<ol>
<li>Did the application handle the flaw correctly?</li>
<li>What in the environment caused the flaw?</li>
</ol>
<p>Usually this is going to involve a division of labor. First off, the application developer is going to look into the answer for question number one. This doesn't mean just error handling and recovery, it also means generating a useful log.</p>
